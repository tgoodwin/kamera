/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"hash/fnv"
	"sort"
	"strings"

	"github.com/go-logr/logr"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/utils/ptr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// EndpointsReconciler reconciles Services and keeps the corresponding Endpoints in sync.
type EndpointsReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups="",resources=services,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=endpoints,verbs=get;list;watch;create;update;patch;delete

// Reconcile ensures the Endpoints resource for a Service mirrors the selected Pods.
func (r *EndpointsReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	svc := &corev1.Service{}
	if err := r.Get(ctx, req.NamespacedName, svc); err != nil {
		if client.IgnoreNotFound(err) != nil {
			logger.Error(err, "unable to fetch Service")
			return ctrl.Result{}, err
		}
		return ctrl.Result{}, nil
	}
	svc.SetGroupVersionKind(corev1.SchemeGroupVersion.WithKind("Service"))

	// ExternalName services do not use Endpoints generated by this controller.
	if svc.Spec.Type == corev1.ServiceTypeExternalName {
		return r.ensureEndpointsAbsent(ctx, svc, logger)
	}

	// Services without selectors are user-managed; leave any existing Endpoints untouched.
	if len(svc.Spec.Selector) == 0 {
		return ctrl.Result{}, nil
	}

	endpoints := &corev1.Endpoints{}
	err := r.Get(ctx, types.NamespacedName{Name: svc.Name, Namespace: svc.Namespace}, endpoints)
	switch {
	case err == nil:
		endpoints.SetGroupVersionKind(corev1.SchemeGroupVersion.WithKind("Endpoints"))
	case errors.IsNotFound(err):
		endpoints = &corev1.Endpoints{
			TypeMeta: metav1.TypeMeta{
				APIVersion: corev1.SchemeGroupVersion.String(),
				Kind:       "Endpoints",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      svc.Name,
				Namespace: svc.Namespace,
			},
		}
		if err := controllerutil.SetControllerReference(svc, endpoints, r.Scheme); err != nil {
			logger.Error(err, "failed to set controller reference on Endpoints")
			return ctrl.Result{}, err
		}
		if err := r.Create(ctx, endpoints); err != nil {
			logger.Error(err, "failed to create Endpoints")
			return ctrl.Result{}, err
		}
	default:
		logger.Error(err, "failed to get Endpoints")
		return ctrl.Result{}, err
	}

	// Adopt endpoints that match the service when orphaned.
	if len(endpoints.OwnerReferences) == 0 && !metav1.IsControlledBy(endpoints, svc) {
		if err := controllerutil.SetControllerReference(svc, endpoints, r.Scheme); err != nil {
			logger.Error(err, "failed to adopt Endpoints")
			return ctrl.Result{}, err
		}
		if err := r.Update(ctx, endpoints); err != nil {
			logger.Error(err, "failed to update adopted Endpoints")
			return ctrl.Result{}, err
		}
	}

	// Respect Endpoints managed by another owner.
	if !metav1.IsControlledBy(endpoints, svc) {
		logger.Info("Endpoints controlled by another owner, skipping", "endpoints", endpoints.Name)
		return ctrl.Result{}, nil
	}

	podList := &corev1.PodList{}
	if err := r.List(ctx, podList,
		client.InNamespace(svc.Namespace),
		client.MatchingLabelsSelector{Selector: labels.SelectorFromSet(svc.Spec.Selector)},
	); err != nil {
		logger.Error(err, "failed to list Pods for Service")
		return ctrl.Result{}, err
	}

	newSubsets := r.buildEndpointSubsets(ctx, svc, podList.Items, logger)

	// Sort subsets for deterministic comparison.
	sortEndpointSubsets(newSubsets)
	currentSubsets := append([]corev1.EndpointSubset(nil), endpoints.Subsets...)
	sortEndpointSubsets(currentSubsets)

	if !equality.Semantic.DeepEqual(currentSubsets, newSubsets) {
		endpoints.Subsets = newSubsets
		if err := r.Update(ctx, endpoints); err != nil {
			logger.Error(err, "failed to update Endpoints subsets")
			return ctrl.Result{}, err
		}
		logger.Info("Updated Endpoints", "service", svc.Name)
	}

	return ctrl.Result{}, nil
}

func (r *EndpointsReconciler) ensureEndpointsAbsent(ctx context.Context, svc *corev1.Service, logger logr.Logger) (ctrl.Result, error) {
	endpoints := &corev1.Endpoints{}
	err := r.Get(ctx, types.NamespacedName{Name: svc.Name, Namespace: svc.Namespace}, endpoints)
	if errors.IsNotFound(err) {
		return ctrl.Result{}, nil
	}
	if err != nil {
		logger.Error(err, "failed to get Endpoints for ExternalName service")
		return ctrl.Result{}, err
	}
	endpoints.SetGroupVersionKind(corev1.SchemeGroupVersion.WithKind("Endpoints"))
	if !metav1.IsControlledBy(endpoints, svc) {
		return ctrl.Result{}, nil
	}
	if err := r.Delete(ctx, endpoints); err != nil {
		logger.Error(err, "failed to delete Endpoints for ExternalName service")
		return ctrl.Result{}, err
	}
	logger.Info("Deleted Endpoints for ExternalName service", "service", svc.Name)
	return ctrl.Result{}, nil
}

func (r *EndpointsReconciler) buildEndpointSubsets(
	ctx context.Context,
	svc *corev1.Service,
	pods []corev1.Pod,
	logger logr.Logger,
) []corev1.EndpointSubset {
	subsets := map[string]*corev1.EndpointSubset{}

	for i := range pods {
		pod := &pods[i]

		if !pod.DeletionTimestamp.IsZero() {
			continue
		}

		ip := endpointIP(pod)
		if ip == "" {
			continue
		}

		ports, ok := resolveEndpointPorts(pod, svc)
		if !ok {
			logger.Info("Skipping pod with unresolved ports", "pod", pod.Name)
			continue
		}

		key := subsetKey(ports)
		subset, exists := subsets[key]
		if !exists {
			// Copy ports to avoid sharing underlying array
			var portCopy []corev1.EndpointPort
			if len(ports) > 0 {
				portCopy = make([]corev1.EndpointPort, len(ports))
				copy(portCopy, ports)
			}
			subset = &corev1.EndpointSubset{Ports: portCopy}
			subsets[key] = subset
		}

		address := endpointAddressForPod(pod)
		if podReady(pod) {
			subset.Addresses = append(subset.Addresses, address)
		} else if svc.Spec.PublishNotReadyAddresses {
			subset.NotReadyAddresses = append(subset.NotReadyAddresses, address)
		}
	}

	var results []corev1.EndpointSubset
	for _, subset := range subsets {
		if len(subset.Addresses) == 0 && len(subset.NotReadyAddresses) == 0 {
			continue
		}
		sort.Slice(subset.Addresses, func(i, j int) bool {
			return subset.Addresses[i].IP < subset.Addresses[j].IP
		})
		sort.Slice(subset.NotReadyAddresses, func(i, j int) bool {
			return subset.NotReadyAddresses[i].IP < subset.NotReadyAddresses[j].IP
		})
		results = append(results, *subset)
	}

	sort.Slice(results, func(i, j int) bool {
		return subsetKey(results[i].Ports) < subsetKey(results[j].Ports)
	})

	return results
}

func endpointIP(pod *corev1.Pod) string {
	if pod.Status.PodIP != "" {
		return pod.Status.PodIP
	}
	if len(pod.Status.PodIPs) > 0 {
		return pod.Status.PodIPs[0].IP
	}
	return syntheticPodIPv4(pod)
}

func endpointAddressForPod(pod *corev1.Pod) corev1.EndpointAddress {
	var nodeName *string
	if pod.Spec.NodeName != "" {
		nodeName = ptr.To(pod.Spec.NodeName)
	}

	address := corev1.EndpointAddress{
		IP:       endpointIP(pod),
		NodeName: nodeName,
		TargetRef: &corev1.ObjectReference{
			APIVersion: corev1.SchemeGroupVersion.String(),
			Kind:       "Pod",
			Namespace:  pod.Namespace,
			Name:       pod.Name,
			UID:        pod.UID,
		},
	}

	if pod.Spec.Hostname != "" {
		address.Hostname = pod.Spec.Hostname
	}

	return address
}

func podReady(pod *corev1.Pod) bool {
	if pod.Status.Phase == corev1.PodFailed || pod.Status.Phase == corev1.PodSucceeded {
		return false
	}
	for _, cond := range pod.Status.Conditions {
		if cond.Type == corev1.PodReady {
			return cond.Status == corev1.ConditionTrue
		}
	}
	return false
}

func resolveEndpointPorts(pod *corev1.Pod, svc *corev1.Service) ([]corev1.EndpointPort, bool) {
	if len(svc.Spec.Ports) == 0 {
		return nil, true
	}

	ports := make([]corev1.EndpointPort, 0, len(svc.Spec.Ports))
	for _, svcPort := range svc.Spec.Ports {
		portNum, err := resolvePortNumber(pod, svcPort)
		if err != nil {
			return nil, false
		}
		epPort := corev1.EndpointPort{
			Name:        svcPort.Name,
			Port:        portNum,
			Protocol:    svcPort.Protocol,
			AppProtocol: svcPort.AppProtocol,
		}
		ports = append(ports, epPort)
	}
	return ports, true
}

func resolvePortNumber(pod *corev1.Pod, svcPort corev1.ServicePort) (int32, error) {
	switch svcPort.TargetPort.Type {
	case intstr.Int:
		if svcPort.TargetPort.IntValue() > 0 {
			return int32(svcPort.TargetPort.IntValue()), nil
		}
		return svcPort.Port, nil
	case intstr.String:
		name := svcPort.TargetPort.String()
		if name == "" {
			return svcPort.Port, nil
		}
		if port, found := findPortByName(pod, name, svcPort.Protocol); found {
			return port, nil
		}
		return 0, fmt.Errorf("port %q not found on pod %s/%s", name, pod.Namespace, pod.Name)
	default:
		return svcPort.Port, nil
	}
}

func findPortByName(pod *corev1.Pod, name string, protocol corev1.Protocol) (int32, bool) {
	proto := protocol
	if proto == "" {
		proto = corev1.ProtocolTCP
	}

	match := func(container corev1.Container) (int32, bool) {
		for _, port := range container.Ports {
			containerProto := port.Protocol
			if containerProto == "" {
				containerProto = corev1.ProtocolTCP
			}
			if port.Name == name && containerProto == proto {
				return port.ContainerPort, true
			}
		}
		return 0, false
	}

	for _, c := range pod.Spec.Containers {
		if port, ok := match(c); ok {
			return port, true
		}
	}
	for _, c := range pod.Spec.InitContainers {
		if port, ok := match(c); ok {
			return port, true
		}
	}
	return 0, false
}

func subsetKey(ports []corev1.EndpointPort) string {
	if len(ports) == 0 {
		return "_"
	}
	keyParts := make([]string, 0, len(ports))
	for _, port := range ports {
		part := fmt.Sprintf("%s/%s/%d", port.Name, port.Protocol, port.Port)
		keyParts = append(keyParts, part)
	}
	sort.Strings(keyParts)
	return strings.Join(keyParts, "|")
}

func sortEndpointSubsets(subsets []corev1.EndpointSubset) {
	sort.Slice(subsets, func(i, j int) bool {
		return subsetKey(subsets[i].Ports) < subsetKey(subsets[j].Ports)
	})
	for i := range subsets {
		sort.Slice(subsets[i].Addresses, func(a, b int) bool {
			return subsets[i].Addresses[a].IP < subsets[i].Addresses[b].IP
		})
		sort.Slice(subsets[i].NotReadyAddresses, func(a, b int) bool {
			return subsets[i].NotReadyAddresses[a].IP < subsets[i].NotReadyAddresses[b].IP
		})
		sort.Slice(subsets[i].Ports, func(a, b int) bool {
			if subsets[i].Ports[a].Port == subsets[i].Ports[b].Port {
				return subsets[i].Ports[a].Name < subsets[i].Ports[b].Name
			}
			return subsets[i].Ports[a].Port < subsets[i].Ports[b].Port
		})
	}
}

func syntheticPodIPv4(pod *corev1.Pod) string {
	key := string(pod.UID)
	if key == "" {
		key = pod.Namespace + "/" + pod.Name
	}

	hasher := fnv.New32a()
	_, _ = hasher.Write([]byte(key))
	sum := hasher.Sum32()

	octet1 := byte(sum >> 16)
	octet2 := byte(sum >> 8)
	octet3 := byte(sum)

	if octet1 == 0 {
		octet1 = 1
	}
	if octet2 == 0 {
		octet2 = 1
	}
	if octet3 == 0 {
		octet3 = 1
	}

	return fmt.Sprintf("10.%d.%d.%d", octet1, octet2, octet3)
}

// SetupWithManager wires the controller into the manager.
func (r *EndpointsReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&corev1.Service{}).
		Owns(&corev1.Endpoints{}).
		Watches(&corev1.Pod{}, handler.EnqueueRequestsFromMapFunc(r.mapPodToServices)).
		Complete(r)
}

func (r *EndpointsReconciler) mapPodToServices(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	pod, ok := obj.(*corev1.Pod)
	if !ok {
		return nil
	}

	if pod.Namespace == "" {
		return nil
	}

	svcList := &corev1.ServiceList{}
	if err := r.List(ctx, svcList, client.InNamespace(pod.Namespace)); err != nil {
		logger.Error(err, "failed to list services for pod event", "pod", pod.Name)
		return nil
	}

	var requests []reconcile.Request
	podLabels := labels.Set(pod.Labels)
	for i := range svcList.Items {
		svc := &svcList.Items[i]
		if len(svc.Spec.Selector) == 0 {
			continue
		}
		selector := labels.SelectorFromSet(svc.Spec.Selector)
		if selector.Matches(podLabels) {
			requests = append(requests, reconcile.Request{
				NamespacedName: types.NamespacedName{
					Namespace: svc.Namespace,
					Name:      svc.Name,
				},
			})
		}
	}

	return requests
}
